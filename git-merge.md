# Teaching git merge

(generated by Gemimi 3.0)

## Pitfalls

When teaching `git merge`, it is helpful to categorize pitfalls into three stages: **Before** (preparation), **During** (the act of merging), and **After** (history and functionality).

Here are the main problems users run into, accompanied by how to explain them.

---

### 1. The "Dirty" Working Directory

**The Problem:** The user tries to merge, but Git refuses because they have uncommitted changes in their current file system that would be overwritten by the merge.
**Error Message:** `error: Your local changes to the following files would be overwritten by merge`

* **Why it happens:** Git protects you from losing work. It won't mix uncommitted work with incoming changes automatically.
* **How to teach it:**
  * Explain that the "table must be clean" before putting new dishes on it.
  * **Solution:** Teach `git stash` (to temporarily hide changes) or force them to commit their current work before merging.

### 2. The Merge Conflict (Textual)

**The Problem:** Two branches have edited the exact same line in a file, or one person edited a file and the other deleted it. Git cannot decide which one is correct.
**Error Message:** `CONFLICT (content): Merge conflict in <file>... Automatic merge failed; fix conflicts and then commit the result.`

* **Why it happens:** Git is smart, but it isn't human. It doesn't know if the function should return `true` or `false` if both were changed.
* **How to teach it:**
  * Show them the "scary" markers: `<<<<<<<`, `=======`, `>>>>>>>`.
  * **Pitfall:** Beginners often delete the markers but leave *both* pieces of code, or delete the code and leave the markers.
  * **Solution:** They must manually edit the file to look exactly how they want it, remove markers, add the file, and commit.

### 3. The "Stuck" State (Panic Mode)

**The Problem:** A user encounters a conflict, gets confused, tries to switch branches to check something, and Git screams at them. They feel trapped in a "merging limbo."

* **Why it happens:** Until a merge is resolved (committed) or aborted, Git puts the repository in a special `(MERGING)` state. Many commands (like `checkout`) are restricted here.
* **How to teach it:**
  * Teach the "Eject Button": **`git merge --abort`**.
  * Explain that this returns the repo to the exact state it was in before they typed `git merge`. It is the ultimate safety net.

### 4. Fast-Forward vs. Merge Commit (The History Mess)

**The Problem:**

* **Scenario A:** The user wants a clear record that a feature was merged, but Git does a "Fast-Forward" (moves the pointer), making it look like the work happened directly on `main`.
* **Scenario B:** The user merges constantly to get updates, creating a "railroad track" history (spaghetti graph) full of empty `Merge branch 'main' into feature` commits.

* **How to teach it:**
  * **Visuals are key here.** Draw a diagram of a pointer moving forward vs. a new bubble being created.
  * **Concept:** Teach the `--no-ff` flag if they want to force a bubble (commit) to preserve the history of a feature branch existing.

### 5. Logical Conflicts (The "Silent Killer")

**The Problem:** The merge completes successfully (no textual conflicts), but the application crashes or fails to build.

* **Example:**
  * Branch A: Changes a function name from `calculateTax()` to `getTax()`.
  * Branch B: Writes new code that calls `calculateTax()`.
  * **Merge:** Git sees these changes are in different files or different lines. It merges happily.
  * **Result:** Code fails because `calculateTax()` no longer exists.
* **How to teach it:**
  * Emphasize that **Git only checks text, not logic.** A clean merge does not mean working code.
  * This is the primary argument for running automated tests *after* a merge.

### 6. The Wrong Direction

**The Problem:** The user is on `feature-branch` and types `git merge main`, when they actually meant to be on `main` and merge in the `feature-branch`.

* **Consequence:** Their feature branch is now polluted with main's history, and `main` is still outdated.
* **How to teach it:**
  * Mnemonic: "Get on the bus you want to bring people onto." (Checkout the target first).
  * Always run `git status` or look at the terminal prompt to verify the current branch before merging.

### 7. Binary File Conflicts

**The Problem:** Two people edited `design.png` or `database.sqlite`.

* **Result:** Git shows a conflict but cannot show diff markers inside an image or binary file.
* **How to teach it:**
  * Explain that Git is built for text.
  * Teach "Theirs" vs. "Ours" for binaries. They have to choose one version completely; they cannot "merge" pixels.
  * Command: `git checkout --theirs path/to/image.png`

### 8. Reverting a Merge (The Advanced Pitfall)

**The Problem:** A user merges a bad branch, pushes it, realizes it broke production, and tries to run `git revert <merge-commit-hash>`.

* **Error:** Git will complain because a merge commit has *two* parents, and Git doesn't know which parent to revert back to.
* **How to teach it:**
  * This is usually an intermediate lesson, but warn them: **Undoing a merge is harder than undoing a regular commit.**
  * They need to specify the "mainline" parent (usually `-m 1`).

### Summary Exercise for Students

To effectively teach this, set up a repository with a prepared conflict:

1. Create a repo.
2. Create branch `A`, change line 1 of `file.txt`, commit.
3. Go back to main, create branch `B`, change line 1 of `file.txt` to something else, commit.
4. Merge `A` into `main`.
5. Ask the student to Merge `B` into `main`.
6. **Watch them panic, then teach them how to resolve it.**

---

Here are detailed, scenario-based examples for each of the 8 pitfalls. You can use these as live-coding scripts or classroom walkthroughs.

---

<!-- markdownlint-disable MD024 -->

### 1. The "Dirty" Working Directory

**Scenario:** You are in the middle of fixing a bug in `styles.css` (youâ€™ve changed the background color), but your boss tells you to merge the latest changes from the `main` branch immediately.

**The Setup:**

```bash
# You are on your feature branch
$ echo "body { background: red; }" > styles.css
# You have NOT committed this change yet
```
<!-- markdownlint-disable MD014 -->

**The Action:**

```bash
$ git merge main
```

**The Result (The Pitfall):**

```text
error: Your local changes to the following files would be overwritten by merge:
    styles.css
Please commit your changes or stash them before you merge.
Aborting
```

**The Fix:**
Explain that Git is refusing to destroy your un-saved work.

```bash
# Option A: Save it to a temporary shelf
$ git stash
$ git merge main
$ git stash pop  # Bring your work back

# Option B: Commit it first
$ git add styles.css
$ git commit -m "WIP: changing background"
$ git merge main
```

---

### 2. The Merge Conflict (Textual)

**Scenario:** Alice and Bob both edit the `README.md` file. Alice changes the project title to "Alpha Project". Bob changes it to "Beta Project". Alice merges her code first. Now Bob tries to merge.

**The Setup (Bob's View):**
Bob has `Title: Beta Project` in his file. The `main` branch has `Title: Alpha Project`.

**The Action:**

```bash
$ git merge main
```

**The Result (The Pitfall):**

```text
Auto-merging README.md
CONFLICT (content): Merge conflict in README.md
Automatic merge failed; fix conflicts and then commit the result.
```

**The "Scary" File Content:**
Bob opens `README.md` and sees this:

```text
<<<<<<< HEAD
Title: Beta Project
=======
Title: Alpha Project
>>>>>>> main
```

**The Fix:**
Bob must delete the markers and choose a winner (or combine them).
*Corrected File Content:*

```text
Title: Alpha Beta Project (Combined)
```

*Terminal:*

```bash
$ git add README.md
$ git commit -m "Resolved merge conflict in README"
```

---

### 3. The "Stuck" State (Panic Mode)

**Scenario:** A student hits the conflict in Example #2. They panic. They decide, "I don't want to deal with this right now, I just want to switch to the `main` branch and look at the file there."

**The Action:**

```bash
# The terminal says (MERGING) next to the branch name
$ git checkout main
```

**The Result (The Pitfall):**

```text
error: you need to resolve your current index first
README.md: needs merge
```

*The student feels trapped. They can't leave, and they can't merge.*

**The Fix:**
Teach the "Eject Button."

```bash
$ git merge --abort
# The repo is instantly reset to the state before they typed 'git merge'.
```

---

### 4. Fast-Forward vs. Merge Commit

**Scenario:** You have a feature branch `login-page` with 5 commits. You merge it into `main`.

**The "Fast-Forward" (Default behavior):**
If `main` hasn't changed since you started, Git just moves the `main` label to the tip of `login-page`.

* **Visual:** A straight line of dots.
* **Problem:** 6 months later, looking at the logs, you cannot tell that those 5 commits belonged to a specific feature. It looks like they were done directly on main.

**The "No-FF" (The Teacher's Preference):**
You force Git to create a "Merge Bubble."

**The Action:**

```bash
$ git merge --no-ff login-page
```

**The Result:**
Git opens a text editor asking for a commit message (default: `Merge branch 'login-page'`).

* **Visual:** The graph splits and reconnects.
* **Benefit:** You can see exactly where the feature started and ended in the history.

---

### 5. Logical Conflicts (The Silent Killer)

**Scenario:** You are working in JavaScript.

* **Branch A (Refactor):** Changes a helper function name in `utils.js`.
  * *Old:* `function sum(a, b)`
  * *New:* `function add(a, b)`
* **Branch B (Feature):** Adds a new file `calc.js` that uses the *old* name.
  * *Code:* `import { sum } from './utils';`

**The Action:**
Git merges Branch A and Branch B.

* `utils.js` was changed by A.
* `calc.js` was created by B.
* They do not touch the same lines.

**The Result (The Pitfall):**

```text
Auto-merging utils.js
Auto-merging calc.js
Merge made by the 'ort' strategy.
```

**Git says "Success!"**

**The Reality:**
When you run the app:

```text
Uncaught TypeError: sum is not a function
```

* **Lesson:** Git is a text merger, not a compiler. It doesn't know that `sum` was renamed to `add`. You *must* run tests after merging.

---

### 6. The Wrong Direction

**Scenario:** A student wants to update the `main` branch with their finished work from `feature-branch`.

**The Mistake:**
They sit on `feature-branch` and run:

```bash
(feature-branch) $ git merge main
```

**The Result (The Pitfall):**

* `feature-branch` now has all the code.
* `main` is still empty/old.
* The student deletes `feature-branch` thinking they are done, effectively deleting their work (unless they push, but the `main` branch on the server is still empty).

**The Analogy:**
"You are driving a bus (your current branch). You stop at a bus stop (the other branch) to pick up passengers. If you are driving the 'Feature' bus and stop at 'Main', you are loading Main onto Feature."

**The Fix:**

```bash
$ git checkout main
$ git merge feature-branch
```

---

### 7. Binary File Conflicts

**Scenario:** A game developer updates a character sprite `hero.png` (adds a hat). Another developer updates `hero.png` (changes boots to red).

**The Action:**

```bash
$ git merge new-boots
```

**The Result (The Pitfall):**

```text
CONFLICT (content): Merge conflict in hero.png
warning: Cannot merge binary files: hero.png (HEAD vs. new-boots)
```

**The Problem:**
You cannot open `hero.png` in a text editor to look for `<<<<<<<` markers. It's just binary garbage data.

**The Fix:**
You must choose one file entirely. You cannot "merge" pixels in Git.

```bash
# Keep MY version (the hat)
$ git checkout --ours hero.png

# OR keep THEIR version (the boots)
$ git checkout --theirs hero.png

$ git add hero.png
$ git commit
```

---

### 8. Reverting a Merge

**Scenario:** You merged `dev` into `main` (Commit Hash: `abc1234`). Five minutes later, the server crashes. You need to undo that merge immediately.

**The Action:**

```bash
$ git revert abc1234
```

**The Result (The Pitfall):**

```text
error: commit abc1234 is a merge but no -m option was given.
```

**The Explanation:**
A normal commit has one parent. A merge commit has two parents (the history of `main`, and the history of `dev`). Git asks: "When I undo this, which history line do you want me to go back to?"

**The Fix:**
You usually want to go back to the "mainline" (Parent 1).

```bash
$ git revert -m 1 abc1234
```

*Note: Warn students that reverting a revert later is very difficult math.*

---

Here is a Markdown file formatted for use with **Pandoc** (to generate Beamer PDFs, Reveal.js, or Slidy presentations).

You can convert this file using a command like:
`pandoc -t beamer slides.md -o slides.pdf`
or
`pandoc -t revealjs -s slides.md -o slides.html`

***

~~~markdown
% Git Merge & Its Pitfalls
% Navigating the Danger Zones
% [Your Name/Date]

---

# The Roadmap

We will categorize merge problems into three stages:

1.  **Before**: Preparation failures (The "Dirty" Directory).
2.  **During**: The act of merging (Conflicts, Wrong Direction).
3.  **After**: History and Logic (Fast-forwards, Logic bugs, Reverts).

---

# 1. The "Dirty" Working Directory

### The Scenario
You are fixing a bug in `styles.css`. You haven't committed yet.
You try to run `git merge main` to get updates.

### The Error
```text
error: Your local changes to the following files
would be overwritten by merge:
    styles.css
Please commit your changes or stash them before you merge.
```

### The Solution

Git protects your unsaved work. You must clear the table before serving new food.

1. **Stash (Hide):** `git stash` -> Merge -> `git stash pop`
2. **Commit (Save):** `git commit -m "WIP"` -> Merge

---

## 2. The Textual Conflict

### The Scenario

Alice changes the Title to "Alpha".
Bob changes the Title to "Beta".
Git cannot decide which is correct.

### The Scary Output

```text
CONFLICT (content): Merge conflict in README.md
Automatic merge failed; fix conflicts and then commit.
```

### The Fix

Open the file. Look for the markers:

```text
<<<<<<< HEAD
Title: Beta
=======
Title: Alpha
>>>>>>> main
```

**Action:** Delete the markers, choose the text you want, save, `git add`, and `git commit`.

---

## 3. The "Stuck" State (Panic Mode)

### The Scenario

You hit a conflict. You panic. You try to switch branches to check something else.

```bash
$ git checkout main
error: you need to resolve your current index first
```

You are trapped in `(MERGING)` limbo.

### The Eject Button

If you want to give up and go back to exactly how things were before you typed merge:

```bash
$ git merge --abort
```

---

## 4. Fast-Forward vs. Merge Commits

### The Scenario

You merge a feature branch. Git simply moves the pointer forward.

* **Result:** Your history is a straight line. You can't tell where the feature started or ended.

### The Fix: `--no-ff`

Force Git to create a "Merge Bubble" (a commit object).

```bash
$ git merge --no-ff feature-login
```

**Why?** It preserves the historical context that a specific feature existed and was merged at a specific time.

---

## 5. Logical Conflicts (The Silent Killer)

### The Scenario

* **Branch A:** Renames `calculateTax()` to `getTax()`.
* **Branch B:** Writes new code calling `calculateTax()`.

### The Merge

Git merges successfully! (Different lines/files).

### The Crash

The app fails at runtime: `Uncaught TypeError: calculateTax is not a function`.

### The Lesson

**Git merges text, not logic.**
A clean merge does not mean working code.
*Always run automated tests after merging.*

---

## 6. The Wrong Direction

### The Scenario

You want to bring `feature` into `main`.
**Mistake:** You are sitting on `feature` and run `git merge main`.

### The Result

* `feature` gets polluted with `main` code.
* `main` stays outdated.

### The Analogy

"Get on the bus you want to bring passengers onto."

### The Fix

Check your branch *before* merging.

```bash
$ git checkout main
$ git merge feature-branch
```

---

## 7. Binary File Conflicts

### The Scenario

Two people edited `hero.png` (an image).

### The Error

```text
warning: Cannot merge binary files: hero.png
CONFLICT (content): Merge conflict in hero.png
```

### The Fix

You cannot edit "pixels" inside a text editor. You must pick a winner.

```bash
# Keep MY version
$ git checkout --ours hero.png

# Keep THEIR version
$ git checkout --theirs hero.png

$ git add hero.png
$ git commit
```

---

## 8. Reverting a Merge (Advanced)

### The Scenario

You merged `dev` into `main`. It broke production. You run `git revert <merge-hash>`.

### The Error

```text
error: commit is a merge but no -m option was given.
```

### The Explanation

A merge has **two parents**. Git doesn't know which side to revert to.

### The Fix

Specify the "Mainline" parent (usually 1).

```bash
$ git revert -m 1 <merge-commit-hash>
```

---

## Summary: The Merge Checklist

1. **Status:** Is my working directory clean? (`git status`)
2. **Location:** Am I on the correct target branch? (`git checkout target`)
3. **Command:** Do I need `--no-ff` to preserve history?
4. **Conflict:**
    * Text? Edit markers.
    * Binary? Choose `--ours` or `--theirs`.
    * Panic? `git merge --abort`.
5. **Verify:** Run tests (Git checks text, you check logic).

---

## Exercise

1. Create a repo with a file `story.txt`.
2. Create branch `A`, change line 1, commit.
3. Go back to main.
4. Create branch `B`, change line 1 (differently), commit.
5. Merge `A` into `main`.
6. **Task:** Merge `B` into `main` and resolve the conflict.
~~~

## Forks and Pull Requests (PRs)

**These are not Git commands.**

`git clone`, `git branch`, and `git merge` are standard Git commands.

**Forks** and **Pull Requests** are features specific to hosting platforms like **GitHub**, GitLab, or Bitbucket.

They are workflows built *on top* of Git to help people collaborate without giving everyone the password to the main server.

## Permissions

**The Problem:**
Imagine you want to fix a bug in a famous open-source project (e.g., React or Linux).

* You cannot run `git push` to their repository.
* Why? Because you don't have permission. If everyone could write to the official code, it would be chaos.

## The "Fork"

**The Solution: The Fork**
A **Fork** is a server-side clone. You tell GitHub: *"Take this repository and make a copy of it under **my** account."*

* **Original Repo:** `facebook/react` (Read-Only for you)
* **Your Fork:** `your-username/react` (Read/Write for you)

Imagine a Google Doc that is "View Only." You cannot edit it. So, you go to **File > Make a Copy**. Now you have an exact duplicate that belongs to you, and you can edit it however you want. The original document remains untouched.

## The Workflow: The "Golden Triangle"

When working with Forks, there are three locations students must understand. I call this the "Golden Triangle."

1. **Upstream:** The original repository (The source of truth).
2. **Origin:** Your Fork on GitHub (Your cloud backup).
3. **Local:** Your computer.

**The Step-by-Step Flow:**

1. **Fork:** Click the "Fork" button on GitHub. (Creates `Origin`).
2. **Clone:** Clone *your fork* to your computer.
    * `git clone https://github.com/your-name/repo.git`
3. **Branch:** Create a feature branch on your computer.
    * `git checkout -b fix-typo`
4. **Commit:** Do the work and save it.
5. **Push:** Push the work *to your fork* (`Origin`).
    * `git push origin fix-typo`
    * *Note:* You cannot push to Upstream!

---

## Pull Request (PR)

Now that your code is on your Fork, the original maintainer doesn't know about it yet. You need to tell them.

A **Pull Request** is a notification you send to the original maintainer saying:
> *"I have made changes on my fork. Please **PULL** these changes into your repository."*

**It is a Request to Merge.**

Behind the scenes, a PR is simply a nice UI for a `git merge`. It allows the maintainers to:

* See the Diff (the changes).
* Comment on specific lines of code (Code Review).
* Run automated tests.
* Click a green button to "Merge" (or close it if they hate it).

You took the "View Only" Google Doc, made a copy, and fixed a spelling error. You now email the owner of the original doc: *"Hey, here is a link to my copy where I fixed that typo. If you like it, copy/paste it into your original."*

## Visualizing the Differences

| Feature | Scope | Who owns it? | Action |
| :--- | :--- | :--- | :--- |
| **Clone** | Local (Your PC) | You | Downloads files to your machine. |
| **Fork** | Server (GitHub) | You | Copies a repo to your GitHub account. |
| **Branch** | Local or Server | You | Creates a parallel version of code. |
| **PR** | Server (GitHub) | Shared | Asks to merge two branches/forks. |

## Common Pitfalls with Forks & PRs

When teaching this, warn students about these common issues:

## The "Stale" Fork

**Scenario:** You forked a repo 6 months ago. Today, you want to fix a bug. You clone your fork and start working.
**Problem:** The original repo (`Upstream`) has had 500 commits since you forked. Your code is based on an ancient version.
**Fix:** You must sync your fork before working.

```bash
# 1. Add the original repo as a remote named 'upstream'
git remote add upstream https://github.com/original-owner/repo.git

# 2. Pull the latest changes from upstream into your local main
git checkout main
git pull upstream main

# 3. Update your fork (origin)
git push origin main
```

## B. PRs from `main`

**Scenario:** A student makes changes directly on their `main` branch and opens a PR.
**Problem:** If they want to work on a *second* feature while the first PR is pending, they are stuck. Any new commits to `main` will automatically appear in the first PR (polluting it).
**Rule:** **Always create a new branch for every PR.** Never submit a PR from `main`.

## C. The "Review Cycle" Confusion

**Scenario:** The maintainer reviews the PR and requests changes (e.g., "Please rename this variable").
**Student Reaction:** The student closes the PR, deletes the branch, makes a new branch, and opens a *new* PR.
**Correct Flow:** Just make the change locally on the *same branch*, commit, and push again. The existing PR will automatically update with the new code.

---

## Summary for Slides

If you want to add a section to your previous slides, here is the Markdown:

```markdown
# GitHub Workflow: Forks & Pull Requests

## 1. What is a Fork?
*   **Git** doesn't know what a fork is. It's a **GitHub** feature.
*   A **Fork** is a copy of a repository under **your** account.
*   **Why?** You don't have permission to push to `facebook/react`. But you *can* push to `your-name/react`.

## 2. The "Golden Triangle"
1.  **Upstream:** The original repo (Read-Only).
2.  **Origin:** Your Fork (Read/Write).
3.  **Local:** Your computer.

**The Flow:**
Upstream -> (Fork) -> Origin -> (Clone) -> Local -> (Push) -> Origin -> (PR) -> Upstream

## 3. What is a Pull Request (PR)?
*   It is a request to **MERGE**.
*   You are asking the maintainer: "Please **pull** my changes into your code."
*   It enables **Code Review** and discussion before merging.

## 4. The Golden Rule of PRs
**Never submit a PR from your `main` branch.**
*   Always create a specific branch (e.g., `fix-login-bug`).
*   Why? So you can work on multiple PRs at once without mixing them up.

## 5. Updating a PR
*   **Scenario:** A maintainer asks for changes.
*   **Do NOT:** Close the PR or create a new one.
*   **DO:** Make changes locally, commit, and `git push`.
*   **Magic:** The PR on GitHub updates automatically!
```
